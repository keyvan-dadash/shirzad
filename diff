diff --git a/Rx.m b/Rx.m
index 28ddc92..3d97288 100644
--- a/Rx.m
+++ b/Rx.m
@@ -1,4 +1,5 @@
-% RX: QPSK/16-QAM over USRP N210 with symbol-rate preamble detection + CFO/phase pre-corr + tight PLL + cumulative BER + EVM
+% RX: QPSK/16-QAM over USRP N210 with symbol-rate preamble detection
+%     + CFO/phase pre-corr + tight PLL + FEC (rate-1/2) + decision-directed SNR
 clear; clc;
 
 assert(exist('comm.SDRuReceiver','class')==8, ...
@@ -6,32 +7,44 @@ assert(exist('comm.SDRuReceiver','class')==8, ...
    'Home > Add-Ons > Get Hardware Support Packages.']);
 
 %% ---------- User/Radio params (MUST MATCH TX) ----------
-fc              = 10e6;     % use 915e6 for SBX/WBX/UBX; 10e6 only for LFRX/LFTX
+fc              = 10e6;     % 10 MHz for LFRX/LFTX; use band-appropriate for SBX/WBX
 MasterClockRate = 100e6;
 Fs              = 1e6;
 Decim           = MasterClockRate/Fs;  assert(round(Decim)==Decim,'Decim must be integer');
 
-M   = 4;                      % 4=QPSK, 16=16-QAM
-bps = log2(M);
-sps = 8;  beta = 0.35; span = 10;
+M   = 4;  bps = log2(M);    % 4=QPSK, 16=16-QAM
+sps = 8;  beta = 0.35; span = 10;    % ★ keep your working sps=8 chain here
 
-preambleLen = 128;            % symbols
-payloadSyms = 2000;           % symbols/frame
+preambleLen = 128;          % symbols
+payloadSyms = 2000;         % symbols/frame
 rxGain_dB   = 0;
 
 SamplesPerFrame = 32768;
 
+%% ---------- FEC (add) ----------
+useFEC = true;                              % toggle on/off
+R    = 1/2;
+trel = poly2trellis(7,[171 133]);
+vitDec = comm.ViterbiDecoder( ...
+    'TrellisStructure', trel, ...
+    'InputFormat','Unquantized', ...        % LLRs: + => '1',  - => '0'
+    'TracebackDepth', 48, ...
+    'TerminationMethod','Truncated');
+tb = vitDec.TracebackDepth;
+
+% Reference *info* bits (same seed as TX) for BER display only:
+infoBitsLen = round(payloadSyms*bps*R);     % 2000
+rng(1001); refBits_info = randi([0 1], infoBitsLen, 1);
+encRefBits  = convenc(refBits_info, trel);  % used ONLY to pick the correct quadrant
+
 %% ---------- Known sequences (match TX exactly) ----------
-rng(1001); refBits = randi([0 1], payloadSyms*bps, 1);  % payload reference bits
 rng(42);   preBits = randi([0 1], preambleLen*bps, 1);  % preamble bits
 preSyms = qammod(preBits, M, 'gray', 'InputType','bit', 'UnitAveragePower', true);
+EpreS   = sum(abs(preSyms).^2);
 
-% Demapper handle
+% Demapper handle for hard bits (used for quadrant + uncoded fallback)
 qamDem = @(z) qamdemod(z, M, 'gray', 'OutputType','bit', 'UnitAveragePower', true);
 
-% (small speed-up) reference constellation for EVM once
-refSymsConst = qammod(refBits, M, 'gray', 'InputType','bit', 'UnitAveragePower', true);
-
 %% ---------- DSP chain ----------
 rrcRX  = comm.RaisedCosineReceiveFilter( ...
     'RolloffFactor',beta,'FilterSpanInSymbols',span, ...
@@ -62,7 +75,7 @@ rx = comm.SDRuReceiver('Platform','N200/N210/USRP2', ...
     'EnableBurstMode',false);
 try, rx.Antenna = 'RX2'; end   % change to 'TX/RX' if that’s your cable
 
-for i=1:10, step(rx); end   % warm up & flush
+for i=1:10, step(rx); end      % warm up & flush
 
 %% ---------- Spectrum analyzer (only visual) ----------
 sa = dsp.SpectrumAnalyzer('SampleRate',Fs, ...
@@ -74,14 +87,12 @@ MU_THR_S  = 0.75;    % normalized corr peak at 1 sps
 PSR_THR_S = 2.0;     % peak-to-sidelobe ratio
 POW_THR_S = 0.95;    % corr-window power / median
 
-EpreS = sum(abs(preSyms).^2);   % energy of symbol-rate preamble
-
 %% ---------- Receive/decode loop ----------
 disp('RX: waiting for frames…');
 yBuf   = complex([]); 
 frames = 0;
 
-% === use normal variables instead of 'persistent' (scripts can't declare persistent) ===
+% cumulative BER counters
 totErr  = 0;
 totBits = 0;
 
@@ -91,7 +102,7 @@ while true
 
     % front-end conditioning
     x = dcblock(x);
-    x = agc(x);
+    if ~useFine, x = agc(x); end
 
     % spectrum view (cheap)
     sa(x);
@@ -142,6 +153,7 @@ while true
 
     if ~bestFound, continue; end
     if ~(best.pk > MU_THR_S && best.PSR > PSR_THR_S && best.pow > POW_THR_S)
+        fprintf('mu: %.1f, psr: %.1f, pow: %.1f\n', best.pk, best.PSR, best.pow);
         continue;  % not a valid preamble yet
     end
 
@@ -169,25 +181,57 @@ while true
     % ---- carrier/phase recovery at 1 sps (coarse then fine after a few frames) ----
     rxSyms_eq = carSyncNow(rxSyms_raw);
 
-    % ---- IQ quadrant/polarity snap (±0/90/180/270°) ----
+    % ---- IQ quadrant/polarity snap (±0/90/180/270°)
+    % ***Minimal change: choose rotation by comparing coded hard bits to encRefBits***
     G = [1, -1, 1j, -1j];
     errs = zeros(1,4);
     for g = 1:4
-        rb = qamDem(rxSyms_eq * G(g));
-        errs(g) = mean(rb ~= refBits);
+        rb = qamDem(rxSyms_eq * G(g));                       % coded hard bits
+        errs(g) = mean(rb(1:numel(encRefBits)) ~= encRefBits(:));   % compare to coded ref
     end
-    [frameBER, ig] = min(errs);
+    [~, ig] = min(errs);
     rxSyms = rxSyms_eq * G(ig);
-    rxBits = qamDem(rxSyms);
 
-    % ---- cumulative BER & EVM-based SNR ----
-    e       = sum(rxBits ~= refBits);
-    totErr  = totErr  + e;
-    totBits = totBits + numel(refBits);
-    cumBER  = totErr / totBits;
+    % ===== Soft LLRs for Viterbi (if FEC enabled) =====
+    if useFEC
+        % Decision-directed error to get noise variance for LLRs (tiny & local change)
+        hb  = qamDem(rxSyms);
+        zh  = qammod(hb, M, 'gray', 'InputType','bit', 'UnitAveragePower', true);
+        cH  = (zh' * rxSyms) / (zh' * zh + eps);       % LS complex gain
+        eV  = rxSyms - cH * zh;
+        varComplex  = max(mean(abs(eV).^2), 1e-8);     % complex noise variance
+        noiseVarLLR = varComplex / 2;                  % per dimension
+
+        llr = qamdemod(rxSyms, M, 'gray', 'OutputType','approxllr', ...
+                       'UnitAveragePower', true, 'NoiseVariance', noiseVarLLR);
+
+        reset(vitDec);
+        decBits = vitDec(llr);
+        if numel(decBits) < tb + infoBitsLen, continue; end
+        decBits = decBits(tb+1 : tb + infoBitsLen);            % drop ramp-in
+
+        % BER on information bits (against same-seed ref)
+        frameBER = mean(decBits ~= refBits_info);
+        totErr   = totErr  + sum(decBits ~= refBits_info);
+        totBits  = totBits + numel(refBits_info);
+    else
+        % Uncoded path (your original)
+        rxBits = qamDem(rxSyms);
+        e       = sum(rxBits ~= refBits);
+        totErr  = totErr  + e;
+        totBits = totBits + numel(refBits);
+        frameBER = e/numel(refBits);
+    end
+    cumBER  = totErr / max(totBits,1);
 
-    evmRMS  = sqrt(mean(abs(rxSyms - refSymsConst).^2) / mean(abs(refSymsConst).^2));
-    SNRdB   = -20*log10(max(evmRMS, eps));     % ≈ Es/N0 (dB)
+    % ---- decision-directed EVM -> Es/N0 (clean SNR) ----
+    hb2 = qamDem(rxSyms);
+    zh2 = qammod(hb2, M, 'gray', 'InputType','bit', 'UnitAveragePower', true);
+    cHd = (zh2' * rxSyms) / (zh2' * zh2 + eps);
+    err = rxSyms - cHd * zh2;
+    Es  = mean(abs(cHd * zh2).^2);
+    Nv  = mean(abs(err).^2);
+    SNRdB = 10*log10(max(Es/Nv, eps));      % ≈ Es/N0 in dB
 
     frames = frames + 1;
     fprintf(['Frame %d | off=%d | mu=%.2f | PSR=%.2f | PowRatio=%.2f | ' ...
@@ -202,8 +246,6 @@ while true
     end
 
     % ---- drop consumed samples from yBuf (SAMPLE-RATE indices) ----
-    % ySym = yBuf(1+off : sps : end).  Symbol index (idxS+payloadSyms) maps to:
-    % sample index = 1 + off + (idxS + payloadSyms)*sps
     needTail_guard = 4*sps;  % small guard at sps
     end_consumed = 1 + off + (idxS + payloadSyms)*sps + needTail_guard - 1;
     end_consumed = min(end_consumed, numel(yBuf));
